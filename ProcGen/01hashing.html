<html>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<head>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/css/materialize.min.css">
		<link rel="stylesheet" href="./styles.css">
		<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/js/materialize.min.js"></script>
		<script src="01hashing.js"></script>
		
	</head>
		
	<body class="brown lighten-3">
		<div class="container row brown lighten-2">
			<div class="card blue-grey lighten-4 center"> 
				<h1>Procedural Generation</h1>
				<h3>Noise functions and Basis for Higher-Order Noise</h3>
			</div>
			
			<div class="col s12">
				<h5>Introduction</h5>
				<p>
					Procedural generation is used in many applications in computer graphics and games. 
					The ideas of Procedural Generation have been around since some time in the late 70s and early 80s.
					At that time, ProcGen was used to get around size limitations, as there was a tight
					limit on the storage and RAM use of programs. It took less space to store a function
					that produced some output, rather than store all of the output of the function.
					The program could just crunch the function and calculate whatever data was needed. 
					For example, in games, storing 2d 'map' data could take up lots of space.
					A function that could produce map data took much less space to store, and could still run very quickly.
					Some early games from the those days like "Beneath Apple Manor" and "Rouge" generated dungeons with rooms and corridors.
					Early predecessors of the modern 'Endless Runner' like River Raid (1982) used ProcGen ideas to place objects as the player moved.
				</p>
				
				<p>
					The techniques used in these old games typically amounted to use of a pseudo-random number generator,
					with a controlled 'seed' value used in the process of generation. Using a different 'seed' would give a different
					pseudo-random sequence, and change the layout of the level. This pseudo-random function would be used for various things,
					like deciding the horizontal position of an object placed on the top of the screen, or the width/length of a room or hallway.
					At the same time, another group of people were using the same techniques, to promote their activities.
				</p>
					
				<div class="col s12 card blue-grey darken-3 center row">
					<div class="card blue-grey darken-2 col s4">
						<div class="card-image">
							<img src="./images/applemanor.gif" />
						</div>
						<h6>Beneath Apple Manor - 1978</h6>
						<span class="tiny">Image from 
							<a href="http://www.myabandonware.com/media/screenshots/b/beneath-apple-manor-256/beneath-apple-manor_5.gif">myabandonware.com</a>
						</span>
					</div>
						
					<div class="card blue-grey darken-2 col s4">
						<div class="card-image">
							<img src="./images/rouge.gif" />
						</div>	
						<h6>Rouge - 1980</h6>
						<span class="tiny">Image from 
							<a href="http://image.dosgamesarchive.com/screenshots/rogue2.gif">dosgamesarchive.com</a>
						</span>
					</div>
					
					<div class="card blue-grey darken-2 col s4">
						<div class="card-image">
							<img src="./images/nethack.gif" />
						</div>	
						<h6>Nethack - 1987</h6>
						<span class="tiny">Image posted on  
							<a href="http://www.echoingthesound.org/community/threads/910-NetHack">echoingthesound.org</a>
							<a href="https://danielkinsman.files.wordpress.com/2011/10/nethack.gif">(direct link)</a>
						</span>
					</div>
					
					
				</div>
				
				<p>
					Demos are tiny programs that were originally inserted alongside pirated software to advertise the skill of the group that 'hacked' 
					that software. These programs were engineered to be as small as possible, and be as optimized as possible, capable of creating
					animated images set to some synthesized music. These little programs inside of pirated software eventually lead to the creation
					of the 'Demoscene' - A group of people who make demos, not for software pirates, but for fun.
				</p>
				
				<p>
					These 'Demos' didn't really use random functions like games did, but instead used mathematical functions to represenat things.
					This allowed them to create programs that produced impressive visuals and sound/music, with a minimal program size and memory usage.
				</p>
				
				<div class="col s12 card blue-grey darken-3 center row">
					<div class="card blue-grey darken-2 col s4 offset-s2">
						<div class="card-image">
							<img src="images/c64-swinth.png" />
						</div>
						<h6>Swinth - 1985</h6>
						<span class="tiny">Image from a video of the demo on 
							<a href="https://www.youtube.com/watch?v=gE3KaHb-GJs">Youtube</a>
						</span>
					</div>
					<div class="card blue-grey darken-2 col s4">
						<div class="card-image">
							<img src="images/c64-christmas.png" />
						</div>
						<h6>Compunet Christmas - 1985</h6>
						<span class="tiny">Image from a video of the demo on 
							<a href="https://www.youtube.com/watch?v=QG8iTTndQgg">Youtube</a>
						</span>
					</div>
				</div>
					
				<p>
					To this day, Procedural Generation is still used, but in many more complex ways. Many games use procedural generation
					to store as little data as possible, and create massive worlds. The game ".kkriger", released in 2004 as an entry into
					a competition, was only 96kb in size, but had graphical fidelity comparable to its industry peers.
				</p>
				<div class="col s12 card blue-grey darken-3 center row">
					<h6>Screenshots from '.kkriger' - 2004 by '.theprodukkt'</h6>
					<div class="card blue-grey darken-2 col s4">
						<div class="card-image">
							<img src="images/kkrieger.png" />
						</div>
					</div>
					<div class="card blue-grey darken-2 col s4">
						<div class="card-image">
							<img src="images/kkrieger2.png" />
						</div>
					</div>
					<div class="card blue-grey darken-2 col s4">
						<div class="card-image">
							<img src="images/kkrieger3.png" />
						</div>
					</div>
					<div class="col s12">
						<span class="tiny">
							Screenshots taken by myself.
							.kkrieger is a 96kb game. A windows download can be found
							<a href="http://www.pouet.net/prod.php?which=12036">here</a>.
						</span>
					</div>
				</div>
				
				<p>
					More recently, 'Graphics Card' technology has gotten powerful enough to generate incredible graphics in real time.
					Through a number of 3d rendering techniques, using Raycasting, objects with mathematically defined topologies, and fractals,
					a shader can be created to render incredibly complex 3d scenes, in real time. No inputs are needed, and the shader 
					calculates and renders the scene, every frame. One recent release, 'Optical Circuit' (Japanese Title '光回路'), released at
					Tokyo Demo Fest 2015. 
				</p>
				
				<div class="col s12 card blue-grey darken-3 center row">
					<h6>Stills from 'Optical Circuit (光回路)' - 2015 by '0x4015'</h6>
					<div class="card card blue-grey darken-2 col s4">
						<div class="card-image">
							<img src="images/OpticalCircuit.jpg" />
						</div>
						
					</div>
					<div class="card card blue-grey darken-2 col s4">
						<div class="card-image">
							<img src="images/OpticalCircuit2.jpg" />
						</div>
						
					</div>
					<div class="card card blue-grey darken-2 col s4">
						<div class="card-image">
							<img src="images/OpticalCircuit3.jpg" />
						</div>
					</div>
					<div class="col s12">
						<span class="tiny">
							Screenshots taken myself. 
							Optical Circuit is a 4kb demo. A windows download can be found
							<a href="http://www.pouet.net/prod.php?which=65125">here</a>.
						</span>
					</div>	
				</div>
				
				<p>
					When worlds are being crafted, pure randomness just creates boring, repetititive garbage.
					For example, terrain generated with just a random diceroll function would be completely incoherent,
					there would be no geological features, but just a sea of peaks and valleys crammed close together.
					We would want to get a better noise function that can be used to create more believable worlds.
				</p>
				
				<p>
					Another property we want is to be able to reproduce the same outcomes for the same inputs. 
					The output of our 'random' functions must not be <i>truely random</i>, but just <i>statistically random.</i>
					A truely random function could not generate the same output for the same input. 
					It's a good thing computers are highly deterministic, as this makes creating predictable,pseudorandom noise much easier,
					and this also has the benefit of making our pseudorandom numbers able to be generated in parallel.
				</p>
				
				<p>
					There will be a few different languages used, mostly Nvidia Cg (C for Graphics) and OpenGLSL
					(Open Graphics Library Shader Language). There are minor differences between
					these two languages, so each code snippit will have the language it is in noted.
					Some of the samples will be created in JavaScript so they can run inside the webpage.
					Other samples will include 'GLSLSandbox' shaders (OpenGLSL code, runs in the browser),
					And executables with Cg shader code.
				</p>

				<h5>Hashing and Noise</h5>
				<p>
					The first, and most basic component of building coherent noise is a form of 
					hash function. The hash functions in this context are a function that takes 
					an input of a Scalar or Vector, and outputs a Scalar, in the range [0,1].
					There are a number of different forms for these hash functions. Here is a 
					formal definition of a Hash Function.
				</p>
			</div> 
			
			<div class="card blue-grey lighten-3 col s10 offset-s1">
				<h4>Hash Function: Definition</h4>
				<p>
					A function that maps data of an arbitrary size to data of a fixed size.
					There are a few properties that are necessary:
					<ol>
						<li>Any input to the function must always produce the same output.</li>
						<li>Any change to the input data produces an unpredictable change in the output.</li>
					</ol>
				</p>
			</div>
			<div class="col s12">
				<p>
					For our purposes of generating textures, input data to our hash functions are floating point Scalars,
					or floating point Vectors any dimension. Our output is a floating point number in the range (0, 1).
					The differences of exclusion or inclusion of 0 and 1 in the output range are insignificant for the overall behaviour.
					Typically, a hash function is completely discontinuous at every point.
				</p>
				
				<p>
					Also, hash functions do not need to be overly complex, a simple function is preferable to a more complex one, 
					so long as they have all of the necessary properties. Here is a pretty complex hash function:
				</p>
					
			</div>
		
			<div class="card blue-grey lighten-4 col s8 offset-s2">
				<div class="chip">(C++)</div><pre>
double IntegerNoise(int n) {
  n = (n >> 13) ^ n;
  int nn = (n * (n * n * 60493 + 19990303) + 1376312589) 
  & 0x7fffffff;
  return 1.0 - ((double)nn / 1073741824.0);
}</pre>
				<span class="small">From <a href="http://libnoise.sourceforge.net/noisegen/index.html">libnoise's documentation</a></span>
			</div>		
			<div class="col s12">
				<p>
					This is quite a complex function, and is much harder to compute per-pixel than it needs to be.
					When rendering noise in real-time, the speed of a 'hash' function must be a consideration.
					Another thing, is that this function won't run as expected when translated for use on a graphics card- There is no 'double' type
					in most languages that compile to Graphics Card assemblies. We would want to have a simpler, faster function, that gives us
					much the same kind of output, and will still work properly on a graphics card.
				</p>
			</div>
			
			<div class="card blue-grey lighten-4 col s8 offset-s2">
				<div class="chip">(NVIDIA CG)</div><pre>
float hash(float n) {
	return frac(sin(n)*SEED);
}</pre>
				<span class="small">Common form of noise function found in various shaders on http://glslsandbox.com/</span>
			</div>
			<div class="col s12">
				<p>
					Now, this function isn't perfect either, in fact, there are drawbacks to this function that the other function doesn't have:
					Floating point rounding can create large 'artifacts' at points that are very far away from zero, and, on different
					hardware (graphics cards), floating point numbers may have different sizes. This results in noise based off of this kind of
					hash function looking different based on the precision of the hardware. Typically, it is expected to be a 32-bit floating point number.
					Depending on the specifics, on older hardware, it may be a 24-bit or 16-bit.
				</p>
				
				<p>
					Lets look at some specific stuff about the smaller, quick hash function.<br>
					<TT>SEED</TT> is a value to scale the distribution of the random function.<br>
					<TT>frac</TT> is a function that returns only the fractional part of the number, as a positive value.<br>
					<br>
					This hash function takes in an input (<tt>n</tt>), 
					passes that input into a (<tt>sin</tt>) function, multiplies the value by a <tt>SEED</tt> value,
					and then drops the integer part of the number, leaving the fractional part.
					<br>
					Changing the <tt>SEED</tt> value changes the output of the hash function quite drastically. 
				</p>
				
				<p>Here is some sample output from the hash function: </p>
			</div>
			
			<div class="card blue-grey darken-4 col s12">
				<h5 class="white-text"><tt>Output from hash(n) for n=(0...500)</tt></h5>
				<tt class="cyan-text text-lighten-3">SEED = 31337.1337</tt>
				<svg viewbox="0 0 520 100" xmlns="http://www.w3.org/2000/svg">
					<g id="hash1" fill="cyan">
					</g>
						
					<g class="graph-lines">
						<line x1="20" x2="600" y1="70" y2="70" />
						<line x1="20" x2="20" y1="20" y2="70" />
					</g>
					
					<g class="graph-labels">
						<text x="12" y="28">1</text>
						<text x="12" y="70">0</text>
						<text x="20" y="80">0</text>
						<text x="500" y="80">500</text>
					</g>
					
				</svg>	
				<tt class="cyan-text text-lighten-3">SEED = 12345.6789</tt>
				<svg viewbox="0 0 520 100" xmlns="http://www.w3.org/2000/svg">
					<g id="hash2" fill="cyan">
					</g>
						
					<g class="graph-lines">
						<line x1="20" x2="600" y1="70" y2="70" />
						<line x1="20" x2="20" y1="20" y2="70" />
					</g>
					
					<g class="graph-labels">
						<text x="12" y="28">1</text>
						<text x="12" y="70">0</text>
						<text x="20" y="80">0</text>
						<text x="500" y="80">500</text>
					</g>
					
				</svg>
			</div>
			
			<div class="col s12">
				<p>
					It should be relatively easy to see that the distribution between these two functions is different,
					just from having a different seed value. The most notable thing about the data here, is that there is no
					COHERENCE in the output. If you went through all of the points, one by one, left to right, the values
					vary wildly. 
					Additionally, we can visualize the values output from hash not as points on a graph, but as colors.
				</p>
				
				<p>
					For the following images, they are made by generating hash values for consecutive numbers,
					mapping those values directly to grayscale colors, where 0 is black and 1 is white, and
					numbers in-between are some shade of gray. Then, placing those colors into a grid.
					The appearance they have is like the harsh 'static' on an untuned television.
				</p>
			</div>
			
			<div class="card blue-grey darken-4 col s12 row">
				<div class="col s12">
					<h5 class="white-text"><tt>Output from 'raw' hash as grayscale textures</tt></h5>
				</div>
				
				<div class="col s4 center">
					<tt class="cyan-text text-lighten-3">SEED = 31337.1337</tt>
					<br>
					<svg viewbox="0 0 1 1" width="100" height="100" xmlns="http://www.w3.org/2000/svg">
						<g id="hash1_grayscale"></g>
					</svg>
					<br>
				</div>
				
				<div class="col s4 center">
					<tt class="cyan-text text-lighten-3">SEED = 12345.6789</tt>
					<br>
					<svg viewbox="0 0 1 1" width="100" height="100" xmlns="http://www.w3.org/2000/svg">
						<g id="hash2_grayscale"></g>
					</svg>
					<br>
				</div>
				<div class="col s4 center">
					<tt class="cyan-text text-lighten-3">SEED = 9876.54321</tt>
					<br>
					<svg viewbox="0 0 1 1" width="100" height="100" xmlns="http://www.w3.org/2000/svg">
						<g id="hash3_grayscale"></g>
					</svg>
					<br>
				</div>
			</div>
					
			<div class="col s12">
				<p>
					Now, that's well and good and all, but, still has no 'coherence'. It's just raw noise, and looks very messy.
					To make noise that has coherence, we utilize the 'raw' noise, sample it at given points, and for points
					in between the samples, blend the values together. 
					We look at this on the <a href="02coherence.html">next page</a>.
				</p>
			</div>
					
			
		</div>
		
	</body>
	
</html>



		


	
	
