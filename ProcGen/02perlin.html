<html>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<head>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/css/materialize.min.css">
		<link rel="stylesheet" href="./styles.css">
		<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/js/materialize.min.js"></script>
		<script src="common.js"></script>
		<script src="gl.js"></script>
		<script src="02perlin.js"></script>
		
	</head>
	<body class="brown lighten-3">
		<div class="container row brown lighten-2">
			<div class="card blue-grey lighten-4 center"> 
				<h1>Procedural Generation</h1>
				<h3>Fractal Noise</h3>
			</div>

			<div class="col s12">
				<h5>Fractals</h5>
				<p>
					Before we dive right into the application to noise, let's just briefly look at fractals, so we can define what 'fractal noise' is.
					Fractals are the result of repeatidly performing some action.
					The most famous examples are the Julia Sets and their map, the Mandelbrot Set. 
					These are generated by taking a simple equation (on complex numbers), <tt>z &lt;=&gt; z^2 + c</tt>, 
					and repeatidly feeding the output back into the function.
				</p>
				<p>
					For these pure mathematical fractals, computers typically have a maximum number of iterations, and an 'escape' length for 'z'
					It applies the function to the starting point, and then feeds that number back into the function, until either:
					<ol>
						<li>The maximum number of iterations has been reached.</li>
						<li>The 'length' of the complex number, z is greater than the 'escape' length.</li>
					</ol>
					Then, based on the number of iterations before escape, the point is assigned some color.
				</p>
				
			</div>
				
			<div class="col s12 card blue-grey darken-3 center row">
				<div class="card blue-grey darken-2 col s4 offset-s2">
					<div class="card-image">
						<img src="images/mandelbrot.png" />
					</div>
					<p>
						A subregion of the mandelbrot.
					</p>
					
				</div>
				<div class="card blue-grey darken-2 col s4">
					<div class="card-image">
						<img src="images/mandelbrotfull.png" />
					</div>
					<p>
						The full mandelbrot set.
					</p>
					
				</div>
			</div>
			<div class="col s12">
				<p>
					The main point of fractals is that they are made by repeating the same process over and over.
					We can use the same idea to apply our noise function on itself, up to a number of times.
				</p>
				
				<p>
					For the purposes of doing some neat stuff in the future, we'll be switching to a 3-dimensional version of our noise function.
					This function is also a bit more robust in terms of period, and more compact in definition.
				</p>
					
			</div>
			<div class="card blue-grey lighten-4 col s8 offset-s2">
				<div class="chip">(NVidia Cg)</div><pre>
float seed;
float hash(float n) { return frac(sin(n)*seed); }
float noise(float3 x) {
    float3 p = floor(x);
    float3 f = frac(x);
    f       = f*f*(3.0-2.0*f);
    float n = p.x + p.y*157.0 + 113.0*p.z;

    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),
                     lerp( hash(n+157.0), hash(n+158.0),f.x),f.y),
                lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
                     lerp( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);
}
</pre>
				<span class="small">Common 3d noise function found on
					<a href="http://glslsandbox.com/">glslSandbox</a> 
					and
					<a href="https://www.shadertoy.com">shadertoy</a>
					adapted to Cg
				</span>
			</div>
			<div class="col s12">
				<p>
					This is a pretty interesting function, and is quite optimized.
					It has an inlined smoothstep applied on the fractional parts, and also fixes in the scales
					of the y and z axis at 157 and 113 (prime numbers). The mass of lerp calls below handle all
					of the interpolation needed, using the calculated 'smoothstep' values from the fractional parts.
					It also still has all of the properties we defined for coherent noise before.
				</p>

				<p>
					Next, we must clarify what is meant by fractal noise, and have examples of how it is built. 
					In the building of fractal noise, we use the basic noise function, and apply many octaves.
					The term 'Octave' is borrowed from music theory, as the typical application doubles the 'frequency' of the noise
					when moving from one octave to the next. Below are 6 live shaders, each rendering what one octave of noise looks like.
				</p>
				
			</div>
			<div class="col s12 center card blue-grey darken-4 row">
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave1" width="150" height="150"></canvas><br>Octave 1
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave2" width="150" height="150"></canvas><br>Octave 2
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave3" width="150" height="150"></canvas><br>Octave 3
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave4" width="150" height="150"></canvas><br>Octave 4
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave5" width="150" height="150"></canvas><br>Octave 5
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave6" width="150" height="150"></canvas><br>Octave 6
				</div>
				<div class="col s12">
					Below is a wave made by combining all of the above waves.
				</div>
				<div class="col s10 offset-s1 center card blue-grey darken-3">
					<canvas id="perlin" width="600" height="300"></canvas><br>Combined wave
				</div>
			</div>
			<div class="col s12">
				<p>
					Each successive octave of noise is applied at twice the 'frequency' of the last.
					The 'period' of the noise is the distance between two 'samples', and just like with sound and music,
					the frequency is the inverse of the 'period'. However, in this case, the wave doesn't 'repeat' the same way.
					It still repeats, but over a much longer period, called the 'Tiling Period'.
				</p>
				<p>
					The other measurement we make is the amplitude of each octave. This amplitude is reduced by a certain amount each octave,
					Called "Persistence". The higher this value, the more of the amplitude 'persists' per octave.
				</p>
				<p>
					Below is the code used to generate a noised value in the range (0, 1) using the 3d noise function defined above.
					
				</p>		
				
			</div>
		
			<div class="card blue-grey lighten-4 col s8 offset-s2">
				<div class="chip">(NVidia Cg)</div><pre>
//Defined externally from function
//so other parts of the program can modify
float scale;
float persistence;
int octaves;
float nnoise(float3 pos, float factor) {
    float total = 0.0        //Total noise accumulated
        , frequency = scale  //Frequency of current octave
        , amplitude = 1.0    //Amplitude of current octave
        , maxAmplitude = 0.0;//Maximum for 'total'
    
	//Accumulate noise over 'octaves' octaves
    for (int i = 0; i &lt octaves; i++) {
        //Apply a single sample of noise at a given amplitude
        total += noise(pos * frequency) * amplitude;
        //Move to next octave
        frequency *= 2.0, maxAmplitude += amplitude;
        amplitude *= persistence;
    }
	
    //Average expected value is half of maximum.
    float avg = maxAmplitude * .5;
    //Normalize the noise based on a 'factor'
    //Factor value chooses how values are mapped to (0, 1)
    //    .5 maps values from .25 to .75 into the range (0, 1)
    //    .2 maps values from .4 to .6 into the range (0, 1)
    //Values above or below the ranges all map to 0 or 1
    if (factor > 0.0) {
        float range = avg * clamp(factor, 0.0, 1.0);
        float mmin = avg - range;
        float mmax = avg + range;
		
        float val = clamp(total, mmin, mmax);
        return val = (val - mmin) / (mmax - mmin);
    } 
	
    //Quickly handles full saturation (factor &lt= 0)
    if (total > avg) { return 1.0; }
    return 0.0;
}
//Default value used for factor, if not specified.
float nnoise(float3 pos) { return nnoise(pos, .5); } 
</pre>
				<span class="small">
					Fractal noise using the same function defined further above.
				</span>
			</div>
			<div class="col s12">
				<p>
					The mapping between 0 and 1 is a very useful feature to have. When applying multiple octaves,
					the accumulated total gets higher and higher, and does eventually converge on some maximum value.
					However, for very high persistence (0.9-1.0), this maximum is very high. 
					Additionally, for any persistence, the output values tend to cluster around the average (1/2 max).
					This makes unfiltered output very dull, with very little contrast.
					This normalization provides additional contrast, and standardizes the output of the function.
				</p>
				<p>
					Even just using 1d noise, it is possible to apply the noise to create 'visual interest' in graphics.
					The following animation was made only noise based off of the x-coordinate of the screen.
				</p>
			</div>
				
			<div class="col s12 center card blue-grey darken-4 row">
				<div class="col s10 offset-s1 center card blue-grey darken-3">
					<canvas id="neonWires" width="600" height="300"></canvas>
				</div>
			</div>
		
			<div class="col s12">
				<p>
					Now, we can apply the same thing to 2d and 3d noises to create 2d and 3d fractal noises.
				</p>
			</div>
				
			<div class="col s12 center card blue-grey darken-4 row">
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="tex1" width="150" height="150"></canvas><br>Octave 1
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="tex2" width="150" height="150"></canvas><br>Octave 2
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="tex3" width="150" height="150"></canvas><br>Octave 3
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="tex4" width="150" height="150"></canvas><br>Octave 4
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="tex5" width="150" height="150"></canvas><br>Octave 5
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="tex6" width="150" height="150"></canvas><br>Octave 6
				</div>
				<div class="col s10 offset-s1 center card blue-grey darken-3">
					<canvas id="texFull" width="600" height="150"></canvas><br>Combined noise
				</div>
			</div>
			
			<div class="col s12">
				<p>
					And then we can use this noise to produce textures. I took a look at a number of photoshop
					tutorials, and adapted them to run off the graphics card.
				</p>
			</div>
			
			<div class="col s12 center card blue-grey darken-4 row">
				<div class="col s4 offset-s4 center card blue-grey darken-3">
					<canvas id="camoWoods" width="200" height="200"></canvas>
				</div>
			</div>
		
		</div>
	</body>
	
</html>