<html>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<head>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/css/materialize.min.css">
		<link rel="stylesheet" href="./styles.css">
		<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/js/materialize.min.js"></script>
		<script src="common.js"></script>
		<script src="gl.js"></script>
		<script src="02perlin.js"></script>
		
	</head>
	<body class="brown lighten-3">
		<div class="container row brown lighten-2">
			<div class="card blue-grey lighten-4 center"> 
				<h1>Procedural Generation</h1>
				<h3>Fractal Noise</h3>
			</div>

			<div class="col s12">
				<h5>Fractals</h5>
				<p>
					Before we dive right into the application to noise, let's just briefly look at fractals, so we can define what 'fractal noise' is.
					Fractals are the result of repeatidly performing some action.
					The most famous examples are the Julia Sets and their map, the Mandelbrot Set. 
					These are generated by taking a simple equation (on complex numbers), <tt>z &lt;=&gt; z^2 + c</tt>, 
					and repeatidly feeding the output back into the function.
				</p>
				<p>
					For these pure mathematical fractals, computers typically have a maximum number of iterations, and an 'escape' length for 'z'
					It applies the function to the starting point, and then feeds that number back into the function, until either:
					<ol>
						<li>The maximum number of iterations has been reached.</li>
						<li>The 'length' of the complex number, z is greater than the 'escape' length.</li>
					</ol>
					Then, based on the number of iterations before escape, the point is assigned some color.
				</p>
				
			</div>
				
			<div class="col s12 card blue-grey darken-3 center row">
				<div class="card blue-grey darken-2 col s4 offset-s2">
					<div class="card-image">
						<img src="images/mandelbrot.png" />
					</div>
					<p>
						A subregion of the mandelbrot.
					</p>
					
				</div>
				<div class="card blue-grey darken-2 col s4">
					<div class="card-image">
						<img src="images/mandelbrotfull.png" />
					</div>
					<p>
						The full mandelbrot set.
					</p>
					
				</div>
			</div>
			<div class="col s12">
				<p>
					The main point of fractals is that they are made by repeating the same process over and over.
					We can use the same idea to apply our noise function on itself, up to a number of times.
				</p>
				
				<p>
					For the purposes of doing some neat stuff in the future, we'll be switching to a 3-dimensional version of our noise function.
					This function is also a bit more robust in terms of period, and more compact in definition.
				</p>
					
			</div>
			<div class="card blue-grey lighten-4 col s8 offset-s2">
				<div class="chip">(NVidia Cg)</div><pre>
float seed;
float hash(float n) { return frac(sin(n)*seed); }
float noise(float3 x) {
    float3 p = floor(x);
    float3 f = frac(x);
    f       = f*f*(3.0-2.0*f);
    float n = p.x + p.y*157.0 + 113.0*p.z;

    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),
                     lerp( hash(n+157.0), hash(n+158.0),f.x),f.y),
                lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
                     lerp( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);
}
</pre>
				<span class="small">Common 3d noise function found on
					<a href="http://glslsandbox.com/">glslSandbox</a> 
					and
					<a href="https://www.shadertoy.com">shadertoy</a>
					adapted to Cg
				</span>
			</div>
			<div class="col s12">
				<p>
					This is a pretty interesting function, and is quite optimized.
					It has an inlined smoothstep applied on the fractional parts, and also fixes in the scales
					of the y and z axis at 157 and 113 (prime numbers). The mass of lerp calls below handle all
					of the interpolation needed, using the calculated 'smoothstep' values from the fractional parts.
					It also still has all of the properties we defined for coherent noise before.
				</p>

				<p>
					Next, we must clarify what is meant by fractal noise, and have examples of how it is built. 
					In the building of fractal noise, we use the basic noise function, and apply many octaves.
					The term 'Octave' is borrowed from music theory, as the typical application doubles the 'frequency' of the noise
					when moving from one octave to the next. Below are 6 live shaders, each rendering what one octave of noise looks like.
				</p>
				
			</div>
			<div class="col s12 center card blue-grey darken-4 row">
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave1" width="150" height="150"></canvas><br>Octave 1
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave2" width="150" height="150"></canvas><br>Octave 2
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave3" width="150" height="150"></canvas><br>Octave 3
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave4" width="150" height="150"></canvas><br>Octave 4
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave5" width="150" height="150"></canvas><br>Octave 5
				</div>
				<div class="col s2 center card blue-grey darken-3">
					<canvas id="octave6" width="150" height="150"></canvas><br>Octave 6
				</div>
				<div class="col s12">
					Below is a wave made by combining all of the above waves.
				</div>
				<div class="col s10 offset-s1 center card blue-grey darken-3">
					<canvas id="perlin" width="600" height="300"></canvas><br>Combined wave
				</div>
			</div>

		</div>
		
	</body>
	
</html>